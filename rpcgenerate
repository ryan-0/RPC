#!/usr/bin/env python

import os
import sys
import json
import pprint
import argparse
import subprocess

proxy_ext = ".proxy.cpp"
stub_ext = ".stub.cpp"
includes = """
#include <cstdio>
#include <cstring>
#include "c150debug.h"
using namespace C150NETWORK;

"""
proxy_setup = """
    c150debug->printf(C150RPCDEBUG,"{proxy_file}: {func_name}() invoked");
    RPCSTUBSOCKET->write("{func_name}", strlen("{func_name}")+1);
    c150debug->printf(C150RPCDEBUG,"{proxy_file}: {func_name}() invocation sent, waiting for response");
    RPCPROXYSOCKET->read(readBuffer, sizeof(readBuffer));
"""

stub_setup = """
    //char doneBuffer[5] = "DONE";
    c150debug->printf(C150RPCDEBUG,"{stub_file}: invoking {func_name}()");
    """

stub_write_to_socket = """
    c150debug->printf(C150RPCDEBUG,"{stub_file}: returned from {func_name}() -- responding to client");
    RPCSTUBSOCKET->write(doneBuffer, sizeof(doneBuffer));
"""

stub_badFunction = """
    void __badFunction(char *{func_name}) {
      char doneBuffer[5] = "BAD";  // to write magic value DONE + null
      c150debug->printf(C150RPCDEBUG,"{stub_file}: received call for nonexistent function %s()",{func_name}});
      RPCSTUBSOCKET->write(doneBuffer, strlen(doneBuffer)+1);
}
"""

stub_getFunctionNameFromStream = """
void getFunctionNameFromStream(char *buffer, unsigned int bufSize) {
  unsigned int i;
  char *bufp;
  bool readnull;
  ssize_t readlen;  
  //
  // Read a message from the stream
  // -1 in size below is to leave room for null
  //
  readnull = false;
  bufp = buffer;
  for (i=0; i< bufSize; i++) {
    readlen = RPCSTUBSOCKET-> read(bufp, 1);  // read a byte
    // check for eof or error
    if (readlen == 0) {
      break;
    }
    // check for null and bump buffer pointer
    if (*bufp++ == '\0') {
      readnull = true;
      break;
    }
  }
  if (readlen == 0) {
    c150debug->printf(C150RPCDEBUG,"simplefunction.stub: read zero length message, checking EOF");
    if (RPCSTUBSOCKET-> eof()) {
      c150debug->printf(C150RPCDEBUG,"simplefunction.stub: EOF signaled on input");

    } else {
      throw C150Exception("simplefunction.stub: unexpected zero length read without eof");
    }
  }
  else if(!readnull) 
    throw C150Exception("simplefunction.stub: method name not null terminated or too long");
}
"""

stub_dispatchFunction = """
void dispatchFunction() {
  char functionNameBuffer[50];
  getFunctionNameFromStream(functionNameBuffer,sizeof(functionNameBuffer));
  if (!RPCSTUBSOCKET-> eof()) {
"""

def stub_boilerplate(declarations): 
        stub.write(stub_dispatchFunction);
        for i,(func,signature) in enumerate(declarations.iteritems()):
            stub.write("\t\tif (strcmp(functionNameBuffer,\"") if (i == 0) else  stub.write("\t\telse if (strcmp(functionNameBuffer,\"") 
            stub.write(func+"\") == 0)\n")
            stub.write("\t\t\t_"+func+ "(")
            nargs = len(signature['arguments'])
            for i, arg in enumerate(signature['arguments']):
                if arg['name'].startswith('__'):
                    print "got something"
                else:
                    stub.write(arg['name'])
                # output comma separator unless at last argument  
                if i < nargs - 1:
                    stub.write(', ')
            stub.write(");\n")
        stub.write(
            """\t\telse
            __badFunction(functionNameBuffer);
    }
}""")


        #stub.write(stub_badFunction.format(stub_file=filename + stub_ext, func_name=func))
        stub.write(stub_getFunctionNameFromStream)


parser = argparse.ArgumentParser(description='Generate proxies and stubs for IDL files')
parser.add_argument('idl_file', nargs='+')
args = parser.parse_args()

def render_arg(arg, declarations):
    arg_name = arg['name']
    arg_type = arg['type']
    
    if declarations['types'][arg['type']]['type_of_type'] != 'array':
        return arg_type, arg_name
    while declarations['types'][arg_type]['type_of_type'] == 'array':
        arg_name += "[%s]" % declarations['types'][arg_type]['element_count']
        arg_type = declarations['types'][arg_type]['member_type']
    return arg_type, arg_name
    

for f in args.idl_file:
    if not os.path.isfile(f):
        sys.stderr.write("Path %s does not designate a file" % f)
        raise "No file named " + f
    if not os.access(f, os.R_OK):
        sys.stderr.write("File %s is not readable" % f)
        raise "File " + f + " not readable"

    # create and open the stub and proxy program files
    filename, extension = os.path.splitext(f) 

    with open(filename + proxy_ext, "w+") as proxy, open(filename + stub_ext, "w+") as stub:
        # generate the json and parse it
        declarations = json.loads(subprocess.check_output(('./idl_to_json', f)))
        pprint.pprint(declarations)

        # write some intitial includes
        proxy.write('#include "%s"\n' % f)
        stub.write('#include "%s"\n' % f)
        proxy.write('#include "rpcproxyhelper.h"\n')
        stub.write('#include "rpcstubhelper.h"\n')
        proxy.write(includes)
        stub.write(includes)
        stub.write('void getFunctionNamefromStream();\n')
        for func, signature in declarations['functions'].iteritems():
            proxy.write(signature['return_type'] + " " +  func + "(")
            stub.write(signature['return_type'] + " _" +  func + "(")
            nargs = len(signature['arguments'])
            for i, arg in enumerate(signature['arguments']):
                if arg['name'].startswith('__'):
                    print "got something"
                else:
                    arg_type, arg_name = render_arg(arg, declarations)
                    proxy.write(arg_type + " " + arg_name)

                # output comma separator unless at last argument  
                if i < nargs - 1:
                    proxy.write(', ')
                    stub.write(', ')
            proxy.write(') {\n')
            stub.write(') {\n')
            proxy.write(proxy_setup.format(proxy_file=filename + proxy_ext, func_name=func))
            stub.write(stub_setup.format(stub_file=filename + stub_ext, func_name=func))
            stub.write(func+ "(")
            nargs = len(signature['arguments'])
            for i, arg in enumerate(signature['arguments']):
                if arg['name'].startswith('__'):
                    print "got something"
                else:
                    stub.write(arg['name'] )
                # output comma separator unless at last argument  
                if i < nargs - 1:
                    stub.write(', ')
            stub.write(");\n")
            stub.write(stub_write_to_socket.format(stub_file=filename + stub_ext, func_name=func))
            

            # TODO: serialize parameters and send to stub

            if signature['return_type'] != 'void':
                proxy.write('    return <ANSWER>;\n')
                stub.write('    return <ANSWER>;\n')
            proxy.write('}\n')
            stub.write('}\n')
        stub_boilerplate(declarations['functions'])
